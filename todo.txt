# Project Requirements
1. Use a Neo4j database for data storage.
2. Implement a Flask application.
3. Use Docker for containerization.
4. Use Docker Compose for multi-container setup.
5. Secure the Flask application with a secret key.
6. Configure the Flask application for development and production environments.
7. Expose the Flask application on port 5000.
8. Use environment variables for configuration.
9. Implement a health check for the Neo4j service.
10. Use NVIDIA GPU resources for the web service.
11. Implement GraphQL endpoint integration.
12. Ensure proper memory and resource allocation for Neo4j.
13. Provide detailed setup and usage instructions.
14. Implement unit tests for the Flask application.

# Current State Analysis
1. Neo4j database is configured in `docker-compose.yml` and `.env` files.
2. Flask application is set up in `Dockerfile` and `docker-compose.yml`.
3. `Dockerfile` and `docker-compose.yml` are correctly configured for containerization.
4. Environment variables are used in `.env` and `docker-compose.yml` files.
5. Health check for Neo4j service is implemented in `docker-compose.yml`.
6. NVIDIA GPU resources are configured in `docker-compose.yml`.
7. GraphQL endpoint is configured in `.env`.
8. Memory and resource allocation for Neo4j is configured in `.env` and `docker-compose.yml`.
9. Setup and usage instructions are provided in `docs/README.md`.
10. Unit tests are not yet implemented.

# Future State Analysis
1. Ensure Flask application follows best practices.
2. Implement modularity using Blueprints.
3. Configure logging for the Flask application.
4. Use configuration classes for different environments.
5. Move existing routes to blueprints.
6. Write unit tests for the Flask application.
7. Add docstrings and comments for clarity.
8. Update documentation to include setup and usage instructions.

# Overview of Work to Accomplish
1. Create a factory function to initialize the Flask app.
2. Set up blueprints for modularity.
3. Configure logging for the Flask application.
4. Use configuration classes for different environments.
5. Move existing routes to blueprints.
6. Write unit tests for the Flask application.
7. Add docstrings and comments for clarity.
8. Update documentation to include setup and usage instructions.

# Detailed Work Packages for Developers

## Work Package 1: Create Factory Function
### Business Requirement
- Implement a Flask application.
### File to be Updated
- `src/__init__.py`
### What the File Needs to Accomplish
- Create a factory function to initialize the Flask app.
- Register blueprints within the factory function.
### Code Suggestions/Examples
```python
// filepath: /d:/Users/crazy/OneDrive/Documents/GitHub/TarkovCultistCircle/src/__init__.py
from flask import Flask
from .config import Config

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)
    # Register blueprints
    from .blueprints.auth import auth_bp
    from .blueprints.main import main_bp
    from .blueprints.api import api_bp
    app.register_blueprint(auth_bp)
    app.register_blueprint(main_bp)
    app.register_blueprint(api_bp)
    # Configure logging
    configure_logging(app)
    return app

def configure_logging(app):
    import logging
    from logging.handlers import RotatingFileHandler
    handler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=1)
    handler.setLevel(logging.INFO)
    app.logger.addHandler(handler)
```

## Work Package 2: Set Up Blueprints
### Business Requirement
- Implement modularity using Blueprints.
### File to be Updated
- `src/blueprints/auth.py`
- `src/blueprints/main.py`
- `src/blueprints/api.py`
### What the File Needs to Accomplish
- Define blueprints for different modules (e.g., `auth`, `main`, `api`).
- Register blueprints in the factory function.
### Code Suggestions/Examples
```python
// filepath: /d:/Users/crazy/OneDrive/Documents/GitHub/TarkovCultistCircle/src/blueprints/auth.py
from flask import Blueprint

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login')
def login():
    return "Login Page"

@auth_bp.route('/logout')
def logout():
    return "Logout Page"
```
```python
// filepath: /d:/Users/crazy/OneDrive/Documents/GitHub/TarkovCultistCircle/src/blueprints/main.py
from flask import Blueprint

main_bp = Blueprint('main', __name__)

@main_bp.route('/')
def home():
    return "Home Page"
```
```python
// filepath: /d:/Users/crazy/OneDrive/Documents/GitHub/TarkovCultistCircle/src/blueprints/api.py
from flask import Blueprint

api_bp = Blueprint('api', __name__)

@api_bp.route('/data')
def get_data():
    return "Data Page"
```

## Work Package 3: Configure Logging
### Business Requirement
- Configure logging for the Flask application.
### File to be Updated
- `src/__init__.py`
### What the File Needs to Accomplish
- Set up logging configuration in the factory function.
- Ensure logs are written to a file and console.
### Code Suggestions/Examples
```python
// filepath: /d:/Users/crazy/OneDrive/Documents/GitHub/TarkovCultistCircle/src/__init__.py
def configure_logging(app):
    import logging
    from logging.handlers import RotatingFileHandler
    handler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=1)
    handler.setLevel(logging.INFO)
    app.logger.addHandler(handler)
```

## Work Package 4: Use Configuration Class
### Business Requirement
- Use configuration classes for different environments.
### File to be Updated
- `src/config.py`
### What the File Needs to Accomplish
- Define configuration classes for different environments (development, production).
- Load the appropriate configuration in the factory function.
### Code Suggestions/Examples
```python
// filepath: /d:/Users/crazy/OneDrive/Documents/GitHub/TarkovCultistCircle/src/config.py
class Config:
    SECRET_KEY = 'your_secret_key'
    NEO4J_URI = 'bolt://localhost:7687'
    NEO4J_USER = 'neo4j'
    NEO4J_PASSWORD = 'your_password'

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False
```

## Work Package 5: Move Existing Routes to Blueprints
### Business Requirement
- Move existing routes to blueprints.
### File to be Updated
- `src/blueprints/main.py`
### What the File Needs to Accomplish
- Ensure routes are defined in separate files under `src/blueprints`.
### Code Suggestions/Examples
```python
// filepath: /d:/Users/crazy/OneDrive/Documents/GitHub/TarkovCultistCircle/src/blueprints/main.py
from flask import Blueprint

main_bp = Blueprint('main', __name__)

@main_bp.route('/')
def home():
    return "Home Page"
```

## Work Package 6: Write Unit Tests
### Business Requirement
- Implement unit tests for the Flask application.
### File to be Updated
- `tests/test_routes.py`
### What the File Needs to Accomplish
- Write unit tests for the Flask application.
- Ensure tests cover routes, models, and utility functions.
### Code Suggestions/Examples
```python
// filepath: /d:/Users/crazy/OneDrive/Documents/GitHub/TarkovCultistCircle/tests/test_routes.py
import unittest
from src import create_app

class RoutesTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app()
        self.client = self.app.test_client()

    def test_home_route(self):
        response = self.client.get('/')
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'Home Page', response.data)

if __name__ == '__main__':
    unittest.main()
```

## Work Package 7: Add Docstrings and Comments
### Business Requirement
- Add docstrings and comments for clarity.
### File to be Updated
- All source files
### What the File Needs to Accomplish
- Add docstrings to all functions and classes.
- Add comments to the codebase for clarity.

## Work Package 8: Update Documentation
### Business Requirement
- Provide detailed setup and usage instructions.
### File to be Updated
- `docs/README.md`
### What the File Needs to Accomplish
- Update documentation to include setup and usage instructions.
### Code Suggestions/Examples
```markdown
// filepath: /d:/Users/crazy/OneDrive/Documents/GitHub/TarkovCultistCircle/docs/README.md
# Tarkov Cultist Circle

## Setup Instructions
1. Clone the repository.
2. Create a virtual environment and activate it.
3. Install the dependencies:
   ```bash
   pip install -r requirements.txt
   ```
4. Set up the environment variables in the `.env` file.
5. Build and run the Docker containers:
   ```bash
   docker-compose up --build
   ```
6. Access the application at `http://localhost:5000`.

## Usage Instructions
- To run the tests:
  ```bash
  python -m unittest discover tests
  ```
```

# Detailed Folder and File Structure

## src/
- `__init__.py`: Factory function to initialize the Flask app, register blueprints, and configure logging.
- `config.py`: Configuration classes for different environments.

## src/blueprints/
- `auth.py`: Authentication routes and logic.
- `main.py`: Main application routes.
- `api.py`: API routes and logic.

## tests/
- `test_routes.py`: Unit tests for the Flask application routes.

## docs/
- `README.md`: Setup and usage instructions.

## Dockerfile
- Ensure it is correctly set up to run the Flask application.

## docker-compose.yml
- Ensure it is correctly set up for multi-container setup with Neo4j and Flask.

## .env
- Ensure all sensitive information is stored in environment variables.
````